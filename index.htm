<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>THESAURUS</title>
    <style>
        p {
            color: black;
            font-family: Arial;
            font-size: 16pt;
            text-align: center;
            width: 640px;
        }
    </style>
    
    <script type="text/javascript" src="WebGl.js"></script>
    <script type="text/javascript" src="ShaderCouleursTextures.js"></script>
    <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
    <script type="text/javascript" src="Transformations.js"></script>

    <script type="text/javascript" src="Camera.js"></script>
    <script type="text/javascript" src="movementCamera.js"></script>
    <!-- <script type="text/javascript" src="detectionObjetAutourJoueur.js"></script> -->

    <script type="text/javascript" src="Textures.js"></script>
    <script type="text/javascript" src="Plancher.js"></script>
    <script type="text/javascript" src="Mur.js"></script>

    <script type="text/javascript" src="Niveau.js"></script>
    <script type="text/javascript">


        let objCanvas = null;
        let objgl = null;
        let objProgShaders = null;
        let objScene3D = null;
        let positionSourisX = null;
        let binTournerCamera = false;
        let binMovAvant = false;
        let binMovArriere = false;
        let binMovDroit = false;
        let binMovGauche = false;
        let binEnMouvement = false;

        const tabImages = ['Transparent.gif', 'Sol.jpg', 'Mur.jpg'];
        const TEX_PLANCHER = 1;
        const TEX_MUR_OUVRABLE = 2;

        // V = non-ouvrable, R = ouvrable, T = tresors, ' ' = corridor
        const tabJeu = 
        [
            ['V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V'],
            ['V', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'V'],
            ['V', ' ', 'R', 'R', 'R', 'R', 'R', 'R', ' ', 'R', 'R', 'R', 'R', 'R', ' ', 'R', ' ', 'R', 'R', 'R', 'R', 'R', ' ', 'R', 'R', 'R', 'R', 'R', 'R', ' ', 'V'],
            ['V', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', ' ', ' ', 'R', ' ', 'R', ' ', 'R', ' ', ' ', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'V'],
            ['V', 'R', 'R', 'R', 'R', 'R', 'R', 'R', ' ', 'R', 'R', ' ', 'R', 'R', ' ', 'R', ' ', 'R', 'R', ' ', 'R', 'R', ' ', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'V'],
            ['V', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'V'],
            ['V', 'R', 'R', 'R', ' ', 'R', 'R', 'R', ' ', 'R', ' ', 'R', 'R', 'R', ' ', 'R', ' ', 'R', 'R', 'R', ' ', 'R', ' ', 'R', 'R', 'R', ' ', 'R', 'R', 'R', 'V'],
            ['V', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'V'],
            ['V', 'R', 'R', 'R', ' ', 'R', 'R', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', 'R', 'R', ' ', 'R', 'R', 'R', 'V'],
            ['V', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'V'],
            ['V', ' ', 'R', 'R', 'R', 'R', 'R', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', 'R', 'R', 'R', 'R', 'R', ' ', 'V'],
            ['V', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', 'R', 'R', 'R', ' ', 'R', ' ', 'R', ' ', 'R', ' ', 'R', 'R', 'R', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', 'V'],
            ['V', 'R', 'R', 'R', 'R', 'R', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', 'R', 'R', 'R', 'R', 'R', 'V'],
            ['V', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', 'R', 'R', 'R', ' ', 'V', 'V', ' ', 'V', 'V', ' ', 'R', 'R', 'R', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', 'V'],
            ['V', ' ', 'R', 'R', 'R', 'R', 'R', 'R', ' ', 'R', ' ', 'R', ' ', 'V', 'T', 'T', 'T', 'V', ' ', 'R', ' ', 'R', ' ', 'R', 'R', 'R', 'R', 'R', 'R', ' ', 'V'],
            ['V', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', 'R', ' ', 'V', 'T', 'T', 'T', 'V', ' ', 'R', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'V'],
            ['V', 'R', 'R', 'R', 'R', 'R', 'R', 'R', ' ', 'R', ' ', 'R', ' ', 'V', 'T', 'T', 'T', 'V', ' ', 'R', ' ', 'R', ' ', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'V'],
            ['V', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', 'R', ' ', 'V', 'V', 'V', 'V', 'V', ' ', 'R', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'V'],
            ['V', ' ', 'R', 'R', 'R', 'R', 'R', 'R', ' ', 'R', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', 'R', ' ', 'R', 'R', 'R', 'R', 'R', 'R', ' ', 'V'],
            ['V', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', 'R', 'R', 'R', 'R', ' ', 'R', 'R', 'R', 'R', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', 'V'],
            ['V', ' ', 'R', ' ', 'R', 'R', 'R', 'R', ' ', 'R', ' ', ' ', ' ', ' ', 'R', ' ', 'R', ' ', ' ', ' ', ' ', 'R', ' ', 'R', 'R', 'R', 'R', ' ', 'R', ' ', 'V'],
            ['V', ' ', 'R', ' ', 'R', ' ', ' ', ' ', ' ', 'R', ' ', 'R', ' ', ' ', 'R', ' ', 'R', ' ', ' ', 'R', ' ', 'R', ' ', ' ', ' ', ' ', 'R', ' ', 'R', ' ', 'V'],
            ['V', ' ', 'R', ' ', 'R', 'R', 'R', 'R', ' ', 'R', ' ', 'R', ' ', 'R', 'R', ' ', 'R', 'R', ' ', 'R', ' ', 'R', ' ', 'R', 'R', 'R', 'R', ' ', 'R', ' ', 'V'],
            ['V', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', 'R', ' ', ' ', ' ', 'R', ' ', ' ', ' ', 'R', ' ', ' ', ' ', 'R', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', 'V'],
            ['V', ' ', 'R', 'R', 'R', 'R', ' ', 'R', ' ', 'R', ' ', 'R', 'R', 'R', ' ', 'R', ' ', 'R', 'R', 'R', ' ', 'R', ' ', 'R', ' ', 'R', 'R', 'R', 'R', ' ', 'V'],
            ['V', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', ' ', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'R', ' ', ' ', ' ', 'R', ' ', ' ', ' ', ' ', ' ', ' ', 'V'],
            ['V', ' ', 'R', ' ', 'R', 'R', ' ', 'R', ' ', 'R', 'R', 'R', ' ', 'R', 'R', ' ', 'R', 'R', ' ', 'R', 'R', 'R', ' ', 'R', ' ', 'R', 'R', ' ', 'R', ' ', 'V'],
            ['V', ' ', 'R', ' ', 'R', ' ', ' ', 'R', ' ', 'R', ' ', ' ', ' ', 'R', ' ', ' ', ' ', 'R', ' ', ' ', ' ', 'R', ' ', 'R', ' ', ' ', 'R', ' ', 'R', ' ', 'V'],
            ['V', 'R', 'R', ' ', 'R', 'R', 'R', 'R', ' ', 'R', ' ', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', ' ', 'R', ' ', 'R', 'R', 'R', 'R', ' ', 'R', 'R', 'V'],
            ['V', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'V'],
            ['V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V'],
        ]


        // Le niveau actuel du jeu
        let intNiveau = 0;

        function demarrer() {
            objCanvas = document.getElementById('monCanvas');
            objCanvas.focus();
            objgl = initWebGL(objCanvas);  // Initialise le contexte WebGL
            objProgShaders = initShaders(objgl);
            objSons = initSons();
            objScene3D = initScene3D(objgl); // Créer la scène

            effacerCanevas(objgl);
            dessiner(objgl, objProgShaders, objScene3D);
            animer();
        }

        // Un cycle d'animation	
        function animer() {
            // Requête pour le prochain cycle
            objCycleAnimation = requestAnimationFrame(animer);

            // Le cycle d'animation
            effacerCanevas(objgl);
            mettreAjourAnimation();
            dessiner(objgl, objProgShaders, objScene3D);
        }

        // Pour mettre à jour l'animation
        function mettreAjourAnimation() {
            if (binEnMouvement) deplacerCamera();
            document.getElementById('posCamX').innerHTML = "posX : " + getPositionCameraX(objScene3D.camera);
            document.getElementById('posCamZ').innerHTML = "posZ : " + getPositionCameraZ(objScene3D.camera);
            document.getElementById('cibleCamX').innerHTML = "cibX : " + getCibleCameraX(objScene3D.camera);
            document.getElementById('cibleCamZ').innerHTML = "cibZ : " + getCibleCameraZ(objScene3D.camera);

            // let fltX = getCibleCameraX(objScene3D.camera) - getPositionCameraX(objScene3D.camera);
            // let fltZ = getCibleCameraZ(objScene3D.camera) - getPositionCameraZ(objScene3D.camera);
            // let fltRayon = Math.sqrt(fltX * fltX + fltZ * fltZ);
            // let intDirection = (binMovAvant) ? 1 : -1;

            // let fltXPrime = intDirection * 1 * Math.cos(Math.acos(fltX / fltRayon));
            // let fltZPrime = intDirection * 1 * Math.sin(Math.asin(fltZ / fltRayon));
        

            detectionObjetAutourJoueur();
            document.getElementById('surJoueur').innerHTML = "Objet Position: " + objScene3D.camera.objAutourJoueur.objAPosJoueur.strType
                + "; " + objScene3D.camera.objAutourJoueur.objAPosJoueur.intX + "; " + objScene3D.camera.objAutourJoueur.objAPosJoueur.intZ;
            document.getElementById('avantJoueur').innerHTML = "Objet Avant: " + objScene3D.camera.objAutourJoueur.objEnAvantJoueur.strType
                + "; " + objScene3D.camera.objAutourJoueur.objEnAvantJoueur.intX + "; " + objScene3D.camera.objAutourJoueur.objEnAvantJoueur.intZ;
            document.getElementById('arriereJoueur').innerHTML = "Objet Arriere: " + objScene3D.camera.objAutourJoueur.objEnArriereJoueur.strType + "; " + objScene3D.camera.objAutourJoueur.objEnArriereJoueur.intX + "; " + objScene3D.camera.objAutourJoueur.objEnArriereJoueur.intZ;

        }


        function initScene3D(objgl) {
            const objScene3D = new Object();
            tabObjets3D = new Array();

            // Mettre les textures dans la scène
            objScene3D.textures = creerTextures(objgl, tabImages);

            const objPlancher = creerObj3DPlancher(objgl, TEX_PLANCHER);
            tabObjets3D.push(objPlancher);

            tabObjets3D = tabObjets3D.concat(initNiveau());   

            objScene3D.tabObjets3D = tabObjets3D;

            // La caméra
            const camera = creerCamera();
            setPositionsCameraXYZ([objPlancher.fltCentrePlancher, 1, objPlancher.fltCentrePlancher], camera);
            setCiblesCameraXYZ([15, 0.5, -8], camera);
            setOrientationsXYZ([0, 1, 0], camera);
            objScene3D.camera = camera;

            return objScene3D;
        }

        function dessiner(objgl, objProgShaders, objScene3D) {
            // La vue
            objgl.viewport(0, 0, objgl.drawingBufferWidth, objgl.drawingBufferHeight);

            // Matrice de projection
            const matProjection = mat4.create();
            const fltRapportCanevas = objgl.drawingBufferWidth / objgl.drawingBufferHeight;
            mat4.perspective(45, fltRapportCanevas, 0.01, 100, matProjection);

            // Relier la matrice aux shaders
            objgl.uniformMatrix4fv(objProgShaders.matProjection, false, matProjection);

            for (let i = 0; i < objScene3D.tabObjets3D.length; i++) {
                const vertex = objScene3D.tabObjets3D[i].vertex;
                const couleurs = objScene3D.tabObjets3D[i].couleurs;
                const texels = objScene3D.tabObjets3D[i].texels;
                const maillage = objScene3D.tabObjets3D[i].maillage;
                const transformations = objScene3D.tabObjets3D[i].transformations;

                // Matrice du modèle            
                const matModeleVue = mat4.create();
                mat4.identity(matModeleVue);

                // Placer la caméra sur la scène
                mat4.lookAt(getPositionsCameraXYZ(objScene3D.camera),
                    getCiblesCameraXYZ(objScene3D.camera),
                    getOrientationsXYZ(objScene3D.camera),
                    matModeleVue);

                // Appliquer les transformations sur le modèle 
                mat4.translate(matModeleVue, getPositionsXYZ(transformations));
                mat4.scale(matModeleVue, getEchellesXYZ(transformations));
                mat4.rotateX(matModeleVue, getAngleX(transformations) * Math.PI / 180);
                mat4.rotateY(matModeleVue, getAngleY(transformations) * Math.PI / 180);
                mat4.rotateZ(matModeleVue, getAngleZ(transformations) * Math.PI / 180);

                // Relier la matrice aux shaders
                objgl.uniformMatrix4fv(objProgShaders.matModeleVue, false, matModeleVue);

                if (maillage == null)
                    // Dessiner les sous-objets
                    for (let j = 0; j <vertex.length; j++) {

                        // Relier les vertex aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex[j]);
                        objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);
                        const intNbVertex = (objgl.getBufferParameter(objgl.ARRAY_BUFFER, objgl.BUFFER_SIZE) / 4) / 3;

                        // Relier les couleurs aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs[j]);
                        objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0);

                        // Activer la texture
                        objgl.activeTexture(objgl.TEXTURE0 + texels[j].intNoTexture);
                        objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels[j].intNoTexture]);

                        // Relier les texels aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, texels[j]);
                        objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

                        // Relier le no de texture et le taux de couleur aux shaders                 
                        objgl.uniform1i(objProgShaders.noTexture, texels[j].intNoTexture);
                        objgl.uniform1f(objProgShaders.pcCouleurTexel, texels[j].pcCouleurTexel);

                        // Dessiner
                        objgl.drawArrays(vertex[j].typeDessin, 0, intNbVertex);
                    }
                else { // Dessiner le maillage

                    // Relier les vertex aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex);
                    objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);

                    // Relier les couleurs aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs);
                    objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0)

                    // Activer la texture
                    objgl.activeTexture(objgl.TEXTURE0 + texels.intNoTexture);
                    objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels.intNoTexture]);

                    // Relier les texels aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, texels);
                    objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

                    // Relier le no de texture et le taux de couleur aux shaders                 
                    objgl.uniform1i(objProgShaders.noTexture, texels.intNoTexture);
                    objgl.uniform1f(objProgShaders.pcCouleurTexel, texels.pcCouleurTexel);

                    // Sélectionner le maillage qu'on va utiliser pour les triangles et les droites
                    objgl.bindBuffer(objgl.ELEMENT_ARRAY_BUFFER, maillage);

                    // Dessiner les triangles
                    objgl.drawElements(objgl.TRIANGLES, maillage.intNbTriangles * 3, objgl.UNSIGNED_SHORT, 0);
                    // Dessiner les droites à la suite des triangles
                    objgl.drawElements(objgl.LINES, maillage.intNbDroites * 2, objgl.UNSIGNED_SHORT, maillage.intNbTriangles * 2 * 3);
                }
            }
        }

        function effacerCanevas(objgl) {
            // Met la couleur d'effacement au noir et complétement opaque
            objgl.clearColor(0.0, 0.0, 0.0, 1.0);
            // Efface les couleurs et le buffer de profondeur.
            objgl.clear(objgl.COLOR_BUFFER_BIT | objgl.DEPTH_BUFFER_BIT);
        }

        function initSons() {
            const objSons = new Object();

            // Ce son joue tout au long du jeu
            let objSon = document.createElement('audio');
            return objSons;
        }

        /**
         * Changer la direction de gauche a droite (x/z) de la camera quand on appuis sur la souris
         * Click gauche seulement
        */
        function eventMouvementSouris() {                 
            if (binTournerCamera === true) {
                mouvementCameraAvecSouris(event);                             
            }            
        }        

        /**
         * Verifier si on click sur la souris et ajoute la position du click
         */
        function eventClickDownSouris() {
            // si on click gauche
            if (event.button == 0) {
                binTournerCamera = true;
                positionSourisX = Math.floor(event.clientX);
                // cacher la souris
                document.body.style.cursor = 'none';
            }
        }
        /**
         * Arrete le mouvement de la camera quand on utilise le click
         */        
        function eventClickUpSouris() {
            if (event.button == 0) {
                binTournerCamera = false;
                // reafficher la souris
                document.body.style.cursor = 'auto';
            }        
        }

        // Mouvement avec clavier (fleche et WASD)
        // Rend le jeux 100x plus fluide
        function mouvementAvecClavier() {
            deplacerCameraClavier(event); 
        }
        // arreter le mouvement quand on relache la touche
        function arretMouvementAvecClavier() {
            arretCameraClavier(event);
        }

        function detectionObjetAutourJoueur() {
            let intX = getPositionCameraX(objScene3D.camera);
            let intZ = getPositionCameraZ(objScene3D.camera);

            fltX = getCibleCameraX(objScene3D.camera) - getPositionCameraX(objScene3D.camera);
            fltZ = getCibleCameraZ(objScene3D.camera) - getPositionCameraZ(objScene3D.camera);
            fltRayon = Math.sqrt(fltX * fltX + fltZ * fltZ);

            // Si primeX = 0 && primeZ = 1 -> Nord
            // Si primeX = 0 && primeZ = -1 -> Sud
            // Si primeX = -1 && primeZ = 0 -> Est
            // Si primeX = 1 && primeZ = 0 -> Ouest
            fltXPrime = Math.cos(Math.acos(fltX / fltRayon));
            fltZPrime = Math.sin(Math.asin(fltZ / fltRayon));

            document.getElementById('primeCamX').innerHTML = "primeX : " + fltXPrime;
            document.getElementById('primeCamZ').innerHTML = "primeZ : " + fltZPrime;

            // Pour savoir dans quelle direction quon regarde
            let strDirection = "";
            if (fltZPrime > 0.5 && fltZPrime < 1) strDirection = "Sud";
            else if (fltZPrime < -0.5 && fltZPrime > -1) strDirection = "Nord";
            else if (fltXPrime > 0.5 && fltXPrime < 1) strDirection = "Est";
            else if (fltXPrime < -0.5 && fltXPrime > -1) strDirection = "Ouest";
            document.getElementById('Direction').innerHTML = "direciton: " + strDirection;

            objScene3D.camera.objAutourJoueur = {
                objAPosJoueur: {
                    strType: tabJeu[Math.floor(intZ)][Math.floor(intX)],
                    intX: Math.floor(intX * objScene3D.tabObjets3D[1].fltLargeur),
                    intZ: Math.floor(intZ * objScene3D.tabObjets3D[1].fltProfondeur),
                },
                objEnAvantJoueur: {
                    strType: tabJeu[Math.floor(intZ+fltZPrime)][Math.floor(intX+fltXPrime)],
                    intX: Math.floor(intX + fltXPrime * objScene3D.tabObjets3D[1].fltLargeur),
                    intZ: Math.floor(intZ + fltZPrime * objScene3D.tabObjets3D[1].fltProfondeur),
                },
                objEnArriereJoueur: {
                    strType: tabJeu[Math.floor(intZ-fltZPrime)][Math.floor(intX-fltXPrime)],
                    intX: Math.floor(intX - fltXPrime * objScene3D.tabObjets3D[1].fltLargeur),
                    intZ: Math.floor(intZ - fltZPrime * objScene3D.tabObjets3D[1].fltProfondeur),
                },
            }            
        }


    </script>
</head>

<body onload="demarrer()">
    <p>THESAURUS</p>
    <canvas id="monCanvas" width="640" height="640" tabIndex="1" onkeydown="mouvementAvecClavier();" onkeyup="arretMouvementAvecClavier();" onmousemove="eventMouvementSouris()" onmousedown="eventClickDownSouris();" onmouseup="eventClickUpSouris();">
        Votre navigateur ne supporte pas la balise canvas
    </canvas>
<br/>
    <span id="posCamX">X : </Span>
    <span id="posCamZ">Z : </Span><br/>
    <span id="cibleCamX">X : </Span>
    <span id="cibleCamZ">Z : </Span><br/>
    <span id="primeCamX">X : </Span>
    <span id="primeCamZ">Z : </Span><br/>
    <span id="surJoueur">Sur : </Span><br/>
    <span id="avantJoueur">Avant : </Span><br/>
    <span id="arriereJoueur">Arriere : </Span><br/>
    <span id="Direction">Direction : </span>

</body>

</html>